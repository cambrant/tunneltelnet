#!/usr/bin/env python

import imp
import sys
import os
import time
import subprocess
import pexpect
from IPy import IP

# Workaround to import tstee without it being a proper Python module.
# imp.load_source('tstee', './tstee')
# import tstee


class TunnelTelnet():
    def __init__(self):
        self.username = None
        self.password = None
        self.CONFIG_FILE = os.path.expanduser('~/.tunneltelnet')
        self.read_config()

    def read_config(self):
        # Load the Python formatted config file and import its data.
        if not os.path.isfile(self.CONFIG_FILE):
            raise Exception('Configuration file does not exist.')
        imp.load_source('config', self.CONFIG_FILE)
        import config

        self.proxyport = config.proxyport
        self.remotedns = config.remotedns
        self.remoteserver = config.remoteserver
        self.domainlist = config.domainlist
        self.proxychains_config = os.path.expanduser(config.proxychains_config)
        self.log_directory = os.path.expanduser(config.log_directory)

    def check_tunnel(self):
        pids = [pid for pid in os.listdir('/proc') if pid.isdigit()]

        for pid in pids:
            try:
                cmdline = open(os.path.join('/proc', pid, 'cmdline'),
                    'rb').read()
                if 'ssh' in cmdline and self.proxyport in cmdline and \
                        self.remoteserver in cmdline:
                    print 'SSH tunnel is up.'
                    return True
            except IOError:
                continue

        # Launch tunnel
        print 'SSH tunnel is down. Connecting to %s...' % self.remoteserver

        subprocess.Popen(['nohup', 'ssh', '-ND', self.proxyport,
            self.remoteserver], stdout=open('/dev/null', 'w'),
            stderr=open('/dev/null', 'w'))

        print 'Waiting for SSH connection to establish...'
        time.sleep(5)
        # Recursively keep trying until the tunnel connection succeeds.
        return self.check_tunnel()

    def is_ip(self, ip):
        try:
            IP(ip)
            return ip
        except:
            return False

    def resolve(self, host):
        if self.is_ip(host):
            # User already provided an IP address. Connect to that.
            return host

        # Iterate through each domain and use 'dig' on the remote host to find
        # the IP address of the host.
        for domain in self.domainlist:
            ip = subprocess.check_output(['proxychains4', '-f',
                self.proxychains_config, '-q', 'dig', '@%s' % self.remotedns,
                'A', '%s.%s' % (host, domain), '+search', '+tcp', '+short'])
            ip = ip.strip()
            if ip:
                if self.is_ip(ip):
                    return ip
                else:
                    print 'Error! Something wrong with the returned IP \
                        address:'
                    print ip
                    return False

    def filter_input_keys(self, key):
        # Send CTRL-h instead of <backspace>, to make backspacing in
        # certain CLIs work better.
        if len(key) == 1:
            if ord(key) == 127:
                key = chr(8)

        return key

    def filter_output_keys(self, key):
        return key

    def connect(self, ip):
        p = pexpect.spawn('proxychains4 -q -f %s telnet %s' %
                (self.proxychains_config, ip))
        p.timeout = 30

        if self.username and self.password:
            try:
                p.expect(':')
                p.sendline(self.username)
                p.expect('word:')
                p.sendline(self.password)
                p.expect('')
            except:
                msg = p.before.split('\r\n')
                if len(msg) > 1:
                    for line in msg:
                        print line
                p.close()
                sys.exit()

        p.interact(input_filter=self.filter_input_keys,
            output_filter=self.filter_output_keys)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print 'Usage: %s <host> [username] [password]' % sys.argv[0]
        sys.exit()

    tt = TunnelTelnet()

    if len(sys.argv) == 4:
        tt.username = sys.argv[2]
        tt.password = sys.argv[3]

    tt.check_tunnel()
    ip = tt.resolve(sys.argv[1])
    if ip:
        tt.connect(ip)
    else:
        print 'Could not find host %s.' % sys.argv[1]
