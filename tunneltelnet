#!/usr/bin/env python

# tunneltelnet 0.2
# This script sets up an SSH tunnel and proxies a telnet session through that
# tunnel, to enable a network administrator to reach network devices without
# having to SSH into a network management server first. This enables remote
# scripting and simple management from a computer outside of the management
# network. Tunneltelnet utilizes dig to first resolve DNS names remotely by
# iterating through a list of DNS search domains. This is useful when having
# multiple domains used in the management network, since the /etc/resolv.conf
# of the remote server won't be used by the local dig.

# Nonstandard requirements:
# - python-pexpect >= 3.1
# - python-IPy >= 0.81
# - proxychains-ng >= 4.10 (https://github.com/rofl0r/proxychains-ng)

# SSH should be set up with passwordless public key authentication to the
# remote server, or more preferably with a password protected private key
# using an SSH agent.

import imp
import sys
import os
import time
import subprocess
import pexpect
from IPy import IP

# TODO: Logging to file is not working at the moment. Needs to be fixed!
# Workaround to import tstee without it being a proper Python module.
# imp.load_source('tstee', './tstee')
# import tstee


class TunnelTelnet():
    def __init__(self):
        self.username = None
        self.password = None
        self.CONFIG_FILE = os.path.expanduser('~/.tunneltelnet')
        self.read_config()

    def read_config(self):
        # Load the Python formatted config file and import its data.
        if not os.path.isfile(self.CONFIG_FILE):
            raise Exception('Configuration file does not exist.')
        imp.load_source('config', self.CONFIG_FILE)
        import config

        self.proxyport = config.proxyport
        self.remotedns = config.remotedns
        self.remoteserver = config.remoteserver
        self.domainlist = config.domainlist
        self.proxychains_config = os.path.expanduser(config.proxychains_config)
        self.log_directory = os.path.expanduser(config.log_directory)

        self.cmdline = "ssh -ND %s %s" % (self.proxyport, self.remoteserver)

        self.tries = 0

    def check_tunnel(self):
        # Check if the SSH tunnel specified in the tunneltelnet configuration
        # file is running and return True if it is.
        # Otherwise, launch a new instance of the SSH tunnel and recursively use
        # this function again to make sure it is running.
        try:
            pid = subprocess.check_output(["pgrep", "-f", self.cmdline])
            print 'SSH tunnel is up.'
            return True
        except:
            pass

        # Launch tunnel
        print 'SSH tunnel is down. Connecting to %s...' % self.remoteserver

        subprocess.Popen(['nohup', self.cmdline.split()],
            stdout=open('/dev/null', 'w'), stderr=open('/dev/null', 'w'))

        print 'Waiting for SSH connection to establish...'
        # Sleeping 10 seconds because the tunnel takes quite a while to be
        # fully established.
        time.sleep(10)

        # Recursively keep trying until the tunnel connection succeeds.
        if self.tries < 5:
            self.tries += 1
            return self.check_tunnel()
        else:
            print 'Unable to bring up SSH tunnel.'
            sys.exit()

    def is_ip(self, ip):
        try:
            IP(ip)
            return ip
        except:
            return False

    def resolve(self, host):
        # Resolve the passed hostname into an IP address, using the DNS tools
        # on the remote server to do it.
        if self.is_ip(host):
            # User already provided an IP address. Connect to that.
            return host

        # Iterate through each domain and use 'dig' on the remote host to find
        # the IP address of the host.
        for domain in self.domainlist:
            try:
                ip = subprocess.check_output(['proxychains4', '-f',
                    self.proxychains_config, '-q', 'dig', '@%s' % self.remotedns,
                    'A', '%s.%s' % (host, domain), '+search', '+tcp', '+short'])
            except:
                print 'Error: Could not resolve hostname through SSH tunnel.'
                return False

            ip = ip.strip()
            if ip:
                if self.is_ip(ip):
                    return ip
                else:
                    print 'Error: The returned IP address does not match \
                        expected format!'
                    print ip
                    return False

    def filter_input_keys(self, key):
        # Send CTRL-h instead of <backspace>, to make backspacing in
        # certain CLIs work better.
        if len(key) == 1:
            if ord(key) == 127:
                key = chr(8)

        return key

    def filter_output_keys(self, key):
        return key

    def connect(self, ip):
        p = pexpect.spawn('proxychains4 -q -f %s telnet %s' %
            (self.proxychains_config, ip))
        p.timeout = 30

        if self.username and self.password:
            try:
                p.expect(':')
                p.sendline(self.username)
                p.expect('word:')
                p.sendline(self.password)
                p.expect('')
            except:
                msg = p.before.split('\r\n')
                if len(msg) > 1:
                    for line in msg:
                        print line
                p.close()
                sys.exit()

        p.interact(input_filter=self.filter_input_keys,
            output_filter=self.filter_output_keys)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print 'Usage: %s <host> [username] [password]' % sys.argv[0]
        sys.exit()

    tt = TunnelTelnet()

    if len(sys.argv) == 4:
        tt.username = sys.argv[2]
        tt.password = sys.argv[3]

    tt.check_tunnel()
    ip = tt.resolve(sys.argv[1])
    if ip:
        tt.connect(ip)
    else:
        print 'Could not find host %s.' % sys.argv[1]
